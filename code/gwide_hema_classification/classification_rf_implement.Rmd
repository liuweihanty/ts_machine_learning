---
title: "gwide_random_forest_implementation"
author: "Weihan Liu"
date: "17/02/2020"
output: html_document
---

Pseudo code for regression random forest implementation:

1.  Given training data set
2.  Select number of trees to build (ntrees)
3.  for i = 1 to ntrees do
4.  |  Generate a bootstrap sample of the original data
5.  |  Grow a regression tree to the bootstrapped data
6.  |  for each split do
7.  |  | Select m variables at random from all p variables
8.  |  | Pick the best variable/split-point among the m
9.  |  | Split the node into two child nodes
10. |  end
11. | Use typical tree model stopping criteria to determine when a tree is complete (but do not prune)
12. end

##Install relevant packages
```{r}
library(randomForest)  
library(e1071)  
library(caret)  
library(ggplot2) 
```


##Read in files
```{r}
gwide <- read.csv("/Users/weihan/Documents/GitHub/ts_machine_learning/data/gwide_hema_classification/gwide_dup_rm.csv")  #duplicated removed
gwide_knn <- read.csv("/Users/weihan/Documents/GitHub/ts_machine_learning/data/gwide_hema_classification/gwide_dup_rm_knn.csv") 
```


##Training and testing data split
```{r}
set.seed(1)
#move the gene column to row names
gwide_knn <- gwide_knn %>% column_to_rownames(var = "Gene")
gwide_knn <- select(gwide_knn, -"X")
head(gwide_knn)
#convert the TS gene status column to factor
#gwide_knn$TS_status <- as.factor(gwide_knn$TS_status)
#split for testing and training data, training data are every gene not on chr 7, tetsing data are everything on chr7

table(gwide_knn$chromosome)
#training(unbalanced)
gwide_train <- gwide_knn %>%
        filter(chromosome != 7 & chromosome != "MT")

table(gwide_train$chromosome)

#there are 17484 non-TS and 943 TS, which caused the problem of classification imbalance. The majority 0s will dominate the training process, thus, we need to make a more balanced training set in terms of the TS label. from the gwide_train table, I extracted all the TSs(~1000 genes) and from the non-TSs, I randomly sampled ~ 1000 genes, and combined these two sets of genes.


#create a balanced training set by taking all TSGene == 1(tumor suppressors), and sample randomly from each chromosome by fraction = 0.06. In this way, in the final training set we will have roughly equal amount of TS and non-TS
gwide_train_balance <- filter(gwide_train,TS_status == 0) %>% 
        grouped_df("chromosome") %>%
        sample_frac(size = 0.06)

gwide_train_balance <- as.data.frame(gwide_train_balance)
gwide_train_balance <- rbind(gwide_train_balance,filter(gwide_train,TS_status == 1))
str(gwide_train_balance)

#creating testing set, which will be all genes on chromosome 7
gwide_test <- gwide_knn %>%
        filter(chromosome == 7)
glimpse(gwide_test)

```


##Hyperparameter tuning
```{r}
#' @ntree: number of trees, default is 500
#' @mtry: number of variables randomly sampled as candidates at each split
#' @samplesize: number of samples(rows) to train on, default = 63.2%
#' @nodesize: minimum size(# of samples) pf the terminal nodes, if small, allows deeper and more complex tree
#' @maxnodes: maximum number of terminal nodes

#grid search
# Establish a list of possible values for mtry, nodesize and sampsize
mtry <- seq(4, ncol(gwide_train_balance) * 0.8, 2)
nodesize <- seq(3, 10, 2)
sampsize <- nrow(gwide_train_balance) * c(0.7,0.8)

# Create a data frame containing all combinations 
hyper_grid <- expand.grid(mtry = mtry, nodesize = nodesize, sampsize = sampsize)

# Create an empty vector to store OOB error values
oob_err <- c()

# Write a loop over the rows of hyper_grid to train the grid of models
for (i in 1:nrow(hyper_grid)) {

    # Train a Random Forest model
    rf_model <- randomForest(formula = TS_status ~ ., 
                          data = select(gwide_train_balance,-c("chromosome","Gene")),
                          mtry = hyper_grid$mtry[i],
                          nodesize = hyper_grid$nodesize[i],
                          sampsize = hyper_grid$sampsize[i])
                          
    # Store OOB error for the model                      
    oob_err[i] <- rf_model$err.rate[nrow(rf_model$err.rate), "OOB"]
}

# Identify optimal set of hyperparmeters based on OOB error
opt_i <- which.min(oob_err)
print(hyper_grid[opt_i,])
```



## fit of random forest model using the optimal hyperparameters
```{r, fig.height=4, fig.width=8}
set.seed(22)
#taking the 
rf = randomForest(TS_status ~ .,  
                   data = select(gwide_train_balance,-c("chromosome","Gene")),importance = TRUE,mtry = 8,nodesize = 5,sampsize = 0.8*nrow(gwide_train_balance))
plot(rf) 
print(rf)
varImpPlot(rf)

```


##Predict the test set
```{r}
# Generate predicted classes using the model object
gwide_test$class_prediction <- predict(object = rf,   # model object 
                            newdata = gwide_test,  # test dataset
                            type = "class") 

#extract the predicted TS genes in the test set
pred_gene <- filter(gwide_test, class_prediction == 1)["Gene"]

#read in the TSGene data
tsgene <- read.csv("/Users/weihan/Documents/GitHub/ts_machine_learning/data/gwide_hema_classification/TSGene_all.csv",stringsAsFactors = FALSE)
#overlapping between TSGene TS and the overlapping gene between 96 TS + predicted ts(our targets)
high_conf_hits <- as.data.frame(pred_gene$Gene[pred_gene$Gene %in% tsgene$GeneSymbol])

write.csv(high_conf_hits,"/Users/weihan/Documents/GitHub/ts_machine_learning/data/gwide_hema_classification/high_conf_hits_TSGene.csv")
```

Check the overlap between Jeremy's datamining 96 TS with the canonical TS
```{r}
jeremy_ts <- read.csv("/Users/weihan/Documents/GitHub/ts_machine_learning/data/96ts_work_data.csv")
jeremy_genes <- jeremy_ts["Gene"]
jeremy_genes$Gene <- as.character(jeremy_genes$Gene)


#overlap between Jelemy's datamining 96 TS and the TSGene database canonical TS
hits <- c()
for (i in 1:length(jeremy_genes$Gene)) {
        if (jeremy_genes$Gene[i] %in% as.character(pred_gene$Gene)){
                hits <- c(hits,jeremy_genes$Gene[i])
        }
      
}
hits #list of Jeremy dataminning 96 TS that overlap with the RF predicted genes

#overlapping between TSGene TS and the overlapping gene between 96 TS + predicted ts(our targets)
pred_gene$Gene[pred_gene$Gene %in% canonical_ts_chr7$Gene]

```

Our hit genes: overlap between predicted chr7 TS and Jeremy's screen genes
 [1] "HNRNPA2B1" "IKZF1"     "YWHAG"     "EIF2AK1"   "KMT2C"     "MCM7"      "KMT2E"     "PTPN12"    "TNRC18"    "AHR"      
[11] "GRB10"     "LUC7L2"    "CASP2"     "CUX1"      "LIMK1"     "IGF2BP3"   "EZH2"      "PLOD3"     "IRF5"      "AGK"      
[21] "JAZF1"     "BCAP29"    "SP4"       "ZNF12"     "ASL"       "PHF14"     "TMEM120A"  "ZNF800"    "PAXIP1"    "ATXN7L1"  
[31] "GNAI1"     "ZSCAN25"   "ZNF467"    "NRF1"      "KCTD7"     "HOXA10"    "CLDN15"    "BRAF"      "ZC3HAV1L"  "ZNF789"   
[41] "PUS7"      "BPGM"      "PTCD1"     "WASL"      "VKORC1L1"  "STX1A"     "AP4M1"     "SEMA3C"    "SMO"       "GTF2IRD1"

The overlap of above with TSGene labeled TS:
 "IKZF1"  "KMT2C"  "PTPN12" "AHR"    "CASP2"  "CUX1"   "EZH2"   "IRF5"   "NRF1" 

##Evaluate the model performance on test set
```{r}

# Calculate the confusion matrix for the test set
cm <- confusionMatrix(data = as.factor(class_prediction),       # predicted classes
                      reference = gwide_test$TS_status)  # actual classes

print(cm)


#AUC of test set
library(pROC)
# Generate predictions on the test set
pred <- predict(object = rf,
            newdata = gwide_test,
            type = "prob")


# Compute the AUC (`actual` must be a binary 1/0 numeric vector)
auc(actual = ifelse(gwide_test$TS_status == 1, 1, 0), 
    predicted = pred[,1])     
```




Use the label from Cancer Gene Census as the ground truth instead of the TSGene
Read in the data and switch the ground truth column
```{r}
#read in the CGC data
CGC_TS <- read.csv("/Users/weihan/Documents/GitHub/ts_machine_learning/data/gwide_hema_classification/GCG_TS.csv",stringsAsFactors = FALSE)
CGC_TS <- CGC_TS$Gene.Symbol 
CGC_TS <- as.data.frame(CGC_TS)
CGC_TS <- CGC_TS %>% mutate("TS_status" = 1) %>% rename(Gene = CGC_TS)

#switch the ground truth column from TSGene to CGC
gwide_knn_CGC <- gwide_knn %>% select(-TS_status) %>%
        full_join(CGC_TS, by = "Gene")
#replace all the NAs in the TS_status columns with 0s
gwide_knn_CGC$TS_status[is.na(gwide_knn_CGC$TS_status)] <- 0
```


Split the training vs testing data
```{r}
#training(unbalanced)
gwide_train_CGC <- gwide_knn_CGC %>%
        filter(chromosome != 7 & chromosome != "MT")

table(gwide_train_CGC$chromosome)


#training(balanced)
gwide_train_balance_CGC <- filter(gwide_train_CGC,TS_status == 0) %>% 
        grouped_df("chromosome") %>%
        sample_frac(size = 0.02)

gwide_train_balance_CGC <- as.data.frame(gwide_train_balance_CGC)
gwide_train_balance_CGC <- rbind(gwide_train_balance_CGC,filter(gwide_train_CGC,TS_status == 1))
str(gwide_train_balance_CGC)

#creating testing set, which will be all genes on chromosome 7
gwide_test_CGC <- gwide_knn_CGC %>%
        filter(chromosome == 7)
glimpse(gwide_test_CGC)
```



